---
layout: post
comments: true
title: The order method
---

Last week and some of this one I was working on changing the `order()` method of `FpGroup`s. Currently SymPy attempts to perform coset enumeration on the trivial subgroup and, if it terminates, the order of the group is the length of the coset table. A somewhat better way, at least theoretically, is to try and find a subgroup of finite index and compute the order of this subgroup separately. The function I've implemented only looks for a finite index subgroup generated by a subset of the group's generators with a pseudo-random element thrown in (this can sometimes give smaller index subgroups and make the computation faster). The PR is [here](https://github.com/sympy/sympy/pull/12761).

The idea is to split the list of generators (with a random element) into two halves and try coset enumeration on one of the halves. To make sure this doesn't go on for too long, it is necessary to limit the number of cosets that the coset enumeration algorithm is allowed to define. (Currently, the only way to set the maximum number of cosets is by changing the class variable `CosetTable.coset_table_max_limit` which is very large (4096000) by default - in the PR, I added a keyword argument to all functions relevant to coset enumeration so that the maximum can be set when calling the function.) If the coset enumeration fails (because the maximum number of cosets was exceeded), try the other half. If this doesn't succeed, double the maximum number of cosets and try again. Once (if) a suitable subgroup is found, the order of the group is just the index times the order of the subgroup. The latter is computed in the same way by having `order()` call itself recursively.

The implementation wasn't hard in itself but I did notice that finding the subgroup's presentation was taking far too long in certain cases (specifically when the subgroup's index wasn't small enough) and spent a while trying to think of a way around it. I think that for cyclic subgroups, there is a way to calculate the order during coset enumeration without having to find the presentation explicitly but I couldn't quite work out how to do that. Perhaps, I will eventually find a way and implement it. For now, I left it as it is. For large groups, coset enumeration will take a long time anyway and at least the new way will be faster in some cases and may also be able to tell if a group is infinite (while coset enumeration on the trivial subgroup wouldn't terminate at all).

Now I am going to actually start working on homomorphisms which will be the main and largest part of my project. I'll begin by writing the `GroupHomomorphism` class in this coming week. This won't actually become a PR for a while but it is easier to do it first because I still have exams in the next several days. After that I'll implement the Knuth-Bendix algorithm for rewriting systems (I might make a start on this later this week as I'll have more time once the exams are over). Then I'll send a PR with rewriting systems and once that's merged, the `GroupHomomorphism` class one, because it would depend on rewriting systems.
