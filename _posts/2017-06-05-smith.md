---
layout: post
comments: true
title: The Smith Normal Form
---

Last week I was working on implementing the Smith Normal Form for matrices over principal ideal domains. I'm still making corrections as the [PR](https://github.com/sympy/sympy/pull/12705) is being reviewed. I used the standard algorithm: use invertable (in the ring) row and column operations to make the matrix diagonal and make sure the diagonal entries have the property that an entry divides all of the entries that come after it (this is described in more detail on [wikipedia](https://en.wikipedia.org/wiki/Smith_normal_form#Algorithm) for example). I ran into trouble when trying to determine the domain of the matrix entries if the user hadn't explicitly specified one. Matrices in SymPy don't have a `.domain` attribute or anything similar, and can contain objects of different types. So, if I did attempt to find some suitable principal ideal domain over which to consider all of them, the only way would be to try a few of the ones that are currently implemented until something fits, and that would have to be extended every time a new domain is implemented and generally sounds tedious to do. I've asked on the [Group Theory channel](https://gitter.im/sympy/GroupTheory) if there was a better way and that started a discussion about changing the `Matrix` class to have a `.domain` or a `.ring` attribute and have the entries checked at construction. In fact, this has been brought up by other people before as well. Unfortunately, adding this attribute would require going over the matrix methods implemented so far and making sure they don't assume anything that might not hold for general rings (especially non-commutative ones: like the determinant in its traditional form wouldn't even make sense; however, it turns out there are several generalisations of determinants to non-commutative rings like [quasideterminants](https://en.wikipedia.org/wiki/Quasideterminant) and [DieudonnÃ© determinant](https://en.wikipedia.org/wiki/Dieudonn%C3%A9_determinant)). And this would probably take quite a while and is not directly related to my project. So in the end we decided to have the function work only for matrices for which a `.ring` attribute has been added manually by the user. For example,
```
>>> from sympy.polys.solvers import RawMatrix as Matrix
>>> from sympy.polys.domains import ZZ
>>> m = Matrix([0,1,3],[2,4,1])
>>> setattr(m, "ring", ZZ)
```
Hopefully, at some point in the future matrices will have this attribute by default.

The Smith Normal Form was necessary to analyse the structure of the abelianisation of a group: abelian groups are modules over integers which is a PID and so the Smith Normal form is applicable if the relators of the abelianisation are written in the form of a matrix. If 0 is one of the abelian invariants (the diagonal entries of the Smith Normal form), then the abelianisation is infinite and so must be the whole group. I've added this test to the `.order()` method for `FpGroup`s and now it is able to terminate with the answer `oo` (infinity) for certain groups for which it wouldn't terminate previously. I hope to extend this further with another way to evaluate the order: trying to find a finite index cyclic subgroup (this can be achieved by generating a random word in the group and considering the coset table corresponging to it), and obtain the order of the group by multiplying the index with the order of the cyclic subgroup. The latter could be infinite, in which case the whole group is. Of course, this might not always terminate, but it will terminate in more cases than coset enumeration applied directly to the whole group. This is also what's done in [GAP](https://www.gap-system.org). 

I have begun working on it but this week is the last before my exams, and I feel that I should spend more time revising. For this reason, I probably wouldn't be able to send a PR with this new test by the end of the week. However, it would most likely be ready by the end of the next one, and considering that the only other thing I planned to do until the first evaluation period was to write (the main parts of) the `GroupHomomorphism` class assuming that the things it depends on (e.g. rewriting systems) are already implemented, I believe I am going to stay on schedule.
